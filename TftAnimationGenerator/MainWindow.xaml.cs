using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using Microsoft.Win32;
using Ookii.Dialogs.Wpf;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using Image = SixLabors.ImageSharp.Image;

namespace TftAnimationGenerator
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private string? _targetFile, _targetFolder;

        public string Prefix { get; set; } = "Anim_";

        public MainWindow()
        {
            InitializeComponent();
            DataContext = this;
        }

        private void BtnOpenFile_Click(object sender, RoutedEventArgs e)
        {
            var fileDialog = new OpenFileDialog
            {
                CheckFileExists = true,
                Filter = "Image Files (*.bmp;*.jpg;*.png;*.gif)|*.bmp;*.jpg;*.png;*.gif|All files (*.*)|*.*",
            };
            
            if (fileDialog.ShowDialog() != true)
            {
                return;
            }

            _targetFile = fileDialog.FileName;
            _targetFolder = null;
        }

        private void BtnOpenFolder_Click(object sender, RoutedEventArgs e)
        {
            var folderDialog = new VistaFolderBrowserDialog();

            if (folderDialog.ShowDialog() != true)
            {
                return;
            }

            _targetFolder = folderDialog.SelectedPath;
            _targetFile = null;
        }

        private void BtnConvert_Click(object sender, RoutedEventArgs e)
        {
            if (_targetFile == null && _targetFolder == null)
            {
                MessageBox.Show("Please select a file or folder");
                return;
            }

            var saveFileDialog = new SaveFileDialog()
            {
                AddExtension = true,
                DefaultExt = ".h",
                Filter = "C / C++ Header (*.h)|*.h|All files (*.*)|*.*",
            };

            if (saveFileDialog.ShowDialog() != true)
            {
                return;
            }

            RunConvert(saveFileDialog.FileName);
        }

        private async void RunConvert(string fileName)
        {
            string[]? files = null;
            if (_targetFile != null)
            {
                files = new[] { _targetFile };
            }
            else if (_targetFolder != null)
            {
                files = Directory.EnumerateFiles(_targetFolder).Where(IsImage).ToArray();
                Array.Sort(files);
            }

            if (files == null || files.Length == 0)
            {
                return;
            }

            Dispatcher.Invoke(() =>
            {
                UpdateUIState(false);
                LblProgressState.Content = $"0 / {files.Length}";
                BarProgressState.Value = 0;
                BarProgressState.Maximum = files.Length;
            });

            await using var targetFileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write);
            await using var streamWriter = new StreamWriter(targetFileStream);
            
            for (var i = 0; i < files.Length; i++)
            {
                if (!TryLoadImage(files[i], out var image))
                {
                    continue;
                }

                if (i == 0)
                {
                    await WriteAnimationHeader(streamWriter, image, files.Length);
                }

                await WriteFrame(streamWriter, image);

                if (i < files.Length - 1)
                {
                    await streamWriter.WriteLineAsync(",");
                }
                else
                {
                    await streamWriter.WriteLineAsync();
                }

                await Dispatcher.InvokeAsync(() =>
                {
                    LblProgressState.Content = $"{i + 1} / {files.Length}";
                    BarProgressState.Value = i + 1;
                });
            }

            await streamWriter.WriteLineAsync("};");
            await streamWriter.FlushAsync();

            Dispatcher.Invoke(() => UpdateUIState(true));
        }

        private async Task WriteAnimationHeader(StreamWriter streamWriter, Image<Rgba32> image, int frameCount)
        {
            await streamWriter.WriteLineAsync("//----------------------------------------------------------------");
            await streamWriter.WriteLineAsync("// This file was generated by TTF Animation Generator");
            await streamWriter.WriteLineAsync("// https://github.com/ComputerBaer/TftAnimationGenerator");
            await streamWriter.WriteLineAsync("//");
            await streamWriter.WriteLineAsync("// Changes to this file may cause incorrect behavior");
            await streamWriter.WriteLineAsync("// and will be lost if the animation is regenerated.");
            await streamWriter.WriteLineAsync("//----------------------------------------------------------------\n");

            await streamWriter.WriteLineAsync($"const int {Prefix}FrameCount = {frameCount};");
            await streamWriter.WriteLineAsync($"const int {Prefix}FrameWidth = {image.Width};");
            await streamWriter.WriteLineAsync($"const int {Prefix}FrameHeight = {image.Height};");

            await streamWriter.WriteLineAsync($"const unsigned short PROGMEM {Prefix}Frames[{frameCount}][{image.Width * image.Height}] = {{");
        }

        private async Task WriteFrame(StreamWriter streamWriter, Image<Rgba32> image)
        {
            await streamWriter.WriteAsync("  { ");

            var pixelBuffer = image.Frames[0].PixelBuffer;
            for (int y = 0; y < pixelBuffer.Height; y++)
            {

                for (int x = 0; x < pixelBuffer.Width; x++)
                {
                    Rgba32 pixel = pixelBuffer[x, y];
                    ushort rgb565 = (ushort)(((pixel.R & 0xf8) << 8) | ((pixel.G & 0xfc) << 3) | (pixel.B >> 3)); // RGB565
                    await streamWriter.WriteAsync($"0x{rgb565:X}");

                    if (x < pixelBuffer.Width - 1)
                    {
                        await streamWriter.WriteAsync(", ");
                    }
                }

                if (y < pixelBuffer.Height - 1)
                {
                    await streamWriter.WriteAsync(", ");
                }
            }

            await streamWriter.WriteAsync(" }");
        }

        private bool TryLoadImage(string fileName, [NotNullWhen(true)] out Image<Rgba32>? image)
        {
            using var fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read);
            
            try
            {
                image = Image.Load<Rgba32>(fileStream);
                return true;
            }
            catch (Exception)
            {
                image = null;
                return false;
            }
        }

        private bool IsImage(string fileName)
        {
            var format = Image.DetectFormat(fileName);
            return format != null;
        }

        private void UpdateUIState(bool state)
        {
            BtnOpenFile.IsEnabled = state;
            BtnOpenFolder.IsEnabled = state;
            TxtCodePrefix.IsEnabled = state;
        }
    }
}
